const isBrowser="object"!=typeof process,VERSION="v2.3.13";function bitLength(t){return t<1?1:Math.floor(Math.log(t)/Math.log(2))+1}function numberToBinary(t,e){let r=t.toString(2),i=[],o=bitLength(t)-1;for(let t=e-1;t>=0;t--){let e=r.charAt(o);i[t]=""===e?0:JSON.parse(e),o--}return i}function makeBinary(t,e){let r;r=void 0!==e?e:function(t){return t+1};let i=[];for(let e=0;e<Math.pow(2,t)-1;e++){let o=r(e);if(bitLength(o)<=t){let r={input:numberToBinary(e,t),output:numberToBinary(o,t)};i.push(r)}}return i}function makeXOR(t){if(t<2)return[];let e=makeBinary(t),r={input:e[e.length-1].output,output:[]};return e.push(r),e.forEach((t=>{delete t.output,t.output=[t.input.reduce(((t,e)=>t+e),0)%2]})),e}Add=function(){},Add.activation=function(t,e,r){if("string"==typeof t)return 1!==e.length||1!==r.length?void DannError.error("One of the functions specified does not have only 1 argument.","Add.activation"):(activations[t]=e,void(activations[t+"_d"]=r));DannError.error("The name argument is not a string.","Add.activation")},Add.loss=function(t,e){"string"==typeof t?2===e.length?lossfuncs[t]=e:DannError.error("The loss function specified can only have 2 argument.","newActivation"):DannError.error("The name argument is not a string.","Add.loss")};const XOR=makeXOR(2);function sigmoid(t){return 1/(1+Math.exp(-t))}function sigmoid_d(t){let e=sigmoid(t);return e*(1-e)}function leakySigmoid(t){return 1/(1+Math.exp(-t))+t/100}function leakySigmoid_d(t){let e=leakySigmoid(t);return e*(1-e)}function siLU(t){return t/(1+Math.exp(-t))}function siLU_d(t){return(1+Math.exp(-t)+t*Math.exp(-t))/Math.pow(1+Math.exp(-t),2)}function tanH(t){return(Math.exp(t)-Math.exp(-t))/(Math.exp(t)+Math.exp(-t))}function tanH_d(t){return 1-Math.pow(tanH(t),2)}function leakyReLUCapped(t){return t>=0&&t<=6?t:t<0?.1*t:6}function leakyReLUCapped_d(t){return t>=0&&t<=6?1:t<0?.1:0}function leakyReLU(t){return t>=0?1*t:.01*t}function leakyReLU_d(t){return t>=0?1:.01}function reLU(t){return t>=0?1*t:0}function reLU_d(t){return t>=0?1:0}function sinc(t){return 0===t?1:Math.sin(t)/t}function sinc_d(t){return 0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t)}function softsign(t){return t/(1+Math.abs(t))}function softsign_d(t){let e=1+Math.abs(t);return 1/(e*e)}function binary(t){return t<=0?0:1}function binary_d(t){return 0}function softplus(t){return Math.log(1+Math.exp(t))}function softplus_d(t){return sigmoid(t)}DannError=function(t,e){this.msg=t,this.method=e},DannError.prototype.warn=function(){isBrowser?(console.error("DannWarning: "+this.msg),console.error("> "+this.method)):(console.error("[33mDannWarning: "+this.msg+"[0m"),console.error("[33m> "+this.method+"[0m")),console.trace()},DannError.prototype.error=function(){isBrowser?(console.warn("DannError: "+this.msg),console.warn("> "+this.method)):(console.warn("[31mDannError: "+this.msg+"[0m"),console.warn("[31m> "+this.method+"[0m")),console.trace()},DannError.warn=function(t,e){isBrowser?(console.warn("DannWarning: "+t),console.warn("> "+e)):(console.warn("[33mDannWarning: "+t+"[0m"),console.warn("[33m> "+e+"[0m")),console.trace()},DannError.error=function(t,e){isBrowser?(console.error("DannError: "+t),console.error("> "+e)):(console.error("[31mDannError: "+t+"[0m"),console.error("[31m> "+e+"[0m")),console.trace()};let activations={sigmoid:sigmoid,sigmoid_d:sigmoid_d,tanH:tanH,tanH_d:tanH_d,siLU:siLU,siLU_d:siLU_d,reLU:reLU,reLU_d:reLU_d,leakyReLU:leakyReLU,leakyReLU_d:leakyReLU_d,sinc:sinc,sinc_d:sinc_d,softsign:softsign,softsign_d:softsign_d,binary:binary,binary_d:binary_d,softplus:softplus,softplus_d:softplus_d,leakySigmoid:leakySigmoid,leakySigmoid_d:leakySigmoid_d,leakyReLUCapped:leakyReLUCapped,leakyReLUCapped_d:leakyReLUCapped_d};function mae(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=abs(o-n)}return i=r/o,i}function bce(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=o*log(n)+(1-o)*log(1-n)}return i=-r/o,i}function lcl(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=log(cosh(n-o))}return i=r/o,i}function mbe(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){r+=e[i]-t[i]}return i=r/o,i}function mael(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i]-t[i];r+=-o*(exp(-o)-1)/(exp(-o)+1)}return i=r/o,i}function rmse(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=pow(o-n,2)}return i=sqrt(r/o),i}function mce(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=pow(abs(o-n),3)}return i=r/o,i}function mse(t,e){let r=0,i=0,o=e.length;for(let i=0;i<o;i++){let o=e[i],n=t[i];r+=pow(o-n,2)}return i=r/o,i}function quantile(t,e,r){let i=r,o=0;for(let r=0;r<e.length;r++)e[r]-t[r]>=0?o+=i*(e[r]-t[r]):o+=(i-1)*(e[r]-t[r]);return o/e.length}let lossfuncs={mae:mae,bce:bce,lcl:lcl,mbe:mbe,mce:mce,mse:mse,rmse:rmse,mael:mael,quantile:quantile};const random=(t,e)=>Math.random(1)*(e-t)+t,exp=t=>Math.exp(t),abs=t=>Math.abs(t),log=t=>Math.log(t),pow=(t,e)=>Math.pow(t,e),round=t=>Math.round(t),sqrt=t=>Math.sqrt(t),cosh=t=>(exp(t)+exp(-t))/2;let poolfuncs={max:function(t){let e=0,r=t.length;for(let i=0;i<r;i++)t[i]>e&&(e=t[i]);return e},min:function(t){let e=1/0,r=t.length;for(let i=0;i<r;i++)t[i]<e&&(e=t[i]);return e},avg:function(t){let e=0,r=t.length;for(let i=0;i<r;i++)e+=t[i];return e/r}};function minify(t){t=(t=(t=(t=(t=(t=(t=(t=(t=(t=(t=(t=t.replace(/ = /g,"=")).replace(/ \+ /g,"+")).replace(/ - /g,"-")).replace(/ \* /g,"*")).replace(/ \/ /g,"/")).replace(/for \(/g,"for(")).replace(/; /g,";")).replace(/\) {/g,"){")).replace(/ < /g,"<")).replace(/ > /g,">")).replace(/ \+= /g,"+=")).replace(/;\}/g,"}");for(let e=0;e<5;e++)t=(t=(t=(t=(t=t.replace(/\{ /g,"{")).replace(/ \{/g,"{")).replace(/\} /g,"}")).replace(/\t/g,"")).replace(/\n/g,"");for(let e=0;e<5;e++)t=t.replace(/; /g,";");return t}function slicestring(t,e){return[t.slice(0,e+1),t.slice(e+1,t.length)]}function toEs6(t){let e=t.toString(),r=e.indexOf("("),i=slicestring(e,r)[1];r=i.indexOf(")");let o=slicestring(i,r-1),n=o[0];return r=o[1].indexOf(")"),minify("("+n+")=>"+slicestring(o[1],r)[1])}Matrix=function(t=0,e=0){this.rows=t,this.cols=e;let r=[[]];for(let i=0;i<t;i++){r[i]=[];for(let t=0;t<e;t++)r[i][t]=0}this.matrix=r},Matrix.prototype.add=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.add");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]+=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]+=t;return this},Matrix.add=function(t,e){let r=new Matrix(t.rows,t.cols);if(t.rows===e.rows&&t.cols===e.cols){for(let i=0;i<r.rows;i++)for(let o=0;o<r.cols;o++)r.matrix[i][o]=t.matrix[i][o]+e.matrix[i][o];return r}DannError.error("Matrix dimensions should match","Matrix.add")},Matrix.prototype.addPercent=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){let i=this.matrix[e][r];this.matrix[e][r]+=i*t}},Matrix.prototype.addRandom=function(t,e){let r=Matrix.make(this.rows,this.cols);if(e<=0||e>1)DannError.error("Probability argument must be between 0 and 1","Matrix.prototype.addRandom");else for(let i=0;i<this.rows;i++)for(let o=0;o<this.cols;o++){let n=this.matrix[i][o];random(0,1)<e&&(r[i][o]=n+n*random(-t,t))}this.set(r)},Matrix.prototype.fillCol=function(t,e){if(!(t>=this.cols)){for(let r=0;r<this.rows;r++)this.matrix[r][t]=e;return this}DannError.error("The column index specified is too large for this matrix.","Matrix.prototype.fillCol")},Matrix.prototype.fillRow=function(t,e){if(!(t>=this.rows))return this.matrix[t].fill(e),this;DannError.error("The row index specified is too large for this matrix.","Matrix.prototype.fillRow")},Matrix.fromArray=function(t){let e=new Matrix(t.length,1);for(let r=0;r<t.length;r++)e.matrix[r][0]=t[r];return e},Matrix.prototype.initiate=function(t=0){if(void 0===t);else{if("number"==typeof t){for(let e=0;e<this.matrix.length;e++)for(let r=0;r<this.matrix[e].length;r++)this.matrix[e][r]=t;return this}DannError.error("The value entered as an argument is not a number","Matrix.prototype.initiate")}},Matrix.prototype.insert=function(t,e,r){if("number"==typeof t)if("number"==typeof e){if("number"==typeof r)return e<this.rows&&r<this.cols?(this.matrix[e][r]=t,this):void DannError.error(" x, y arguments exceed the matrix dimensions.","Matrix.prototype.insert");DannError.error('Expected Number for "y" argument',"Matrix.prototype.insert")}else DannError.error('Expected Number for "x" argument',"Matrix.prototype.insert");else DannError.error('Expected Number for "value" argument',"Matrix.prototype.insert")},Matrix.prototype.log=function(t){let e=!1;void 0!==t&&t.table&&(e=t.table),e?console.table(this.matrix):console.log(this)},Matrix.make=function(t=0,e=0){let r=[[]];for(let i=0;i<t;i++){r[i]=[];for(let t=0;t<e;t++)r[i][t]=0}return r},Matrix.prototype.map=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++){let i=this.matrix[e][r];this.matrix[e][r]=t(i)}return this},Matrix.map=function(t,e){if(t instanceof Matrix){for(let r=0;r<t.rows;r++)for(let i=0;i<t.cols;i++){let o=t.matrix[r][i];t.matrix[r][i]=e(o)}return t}DannError.error("First argument must be an instance of Matrix","Matrix.map")},Matrix.prototype.mult=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("The matrix dimensions should match in order to multiply their values. If you are looking for dot product, try Matrix.mult","Matrix.prototype.mult");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]*=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]*=t;return this},Matrix.mult=function(t,e,r={mode:"cpu"}){if(void 0!==r&&r.mode&&(mode=r.mode),"cpu"===mode){let r=new Matrix(t.rows,e.cols);if(t instanceof Matrix&&e instanceof Matrix){if(t.cols!==e.rows)return void DannError.error("The rows of B must match the columns of A","Matrix.mult");for(let i=0;i<r.rows;i++)for(let o=0;o<r.cols;o++){let n=0;for(let r=0;r<t.cols;r++)n+=t.matrix[i][r]*e.matrix[r][o];r.matrix[i][o]=n}return r}}else DannError.error("mode specified is not valid","Matrix.prototype.mult")},Matrix.prototype.randomize=function(t,e){for(let r=0;r<this.matrix.length;r++)for(let i=0;i<this.matrix[r].length;i++)this.matrix[r][i]=random(t,e);return this},Matrix.prototype.set=function(t){"number"==typeof t.length&&"number"==typeof t[0].length&&"object"==typeof t?(this.matrix=t,this.rows=t.length,this.cols=t[0].length):DannError.error("the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]","Matrix.prototype.set")},Matrix.prototype.sub=function(t){if(t instanceof Matrix){if(this.rows!==t.rows||this.cols!==t.cols)return void DannError.error("Matrix dimensions should match","Matrix.prototype.sub");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]-=t.matrix[e][r];return this}for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)this.matrix[e][r]-=t;return this},Matrix.sub=function(t,e){if(t instanceof Matrix&&e instanceof Matrix){if(t.rows!==e.rows||t.cols!==e.cols)return void DannError.error("The matrix dimensions should match","Matrix.sub");{let r=new Matrix(t.rows,t.cols);for(let i=0;i<r.rows;i++)for(let o=0;o<r.cols;o++)r.matrix[i][o]=t.matrix[i][o]-e.matrix[i][o];return r}}DannError.error("The arguments should be p5.MatrixTensors","Matrix.sub")},Matrix.prototype.toArray=function(){let t=[];if(1===this.cols){for(let e=0;e<this.rows;e++)t[e]=this.matrix[e][0];return t}return 1===this.rows?(t=this.matrix[0],t):void DannError.error("None of the lengths of the matrix equal 1","Matrix.prototype.toArray")},Matrix.toArray=function(t){let e=[];if(1===t.cols){for(let r=0;r<t.rows;r++)e[r]=t.matrix[r][0];return e}return 1===t.rows?(e=t.matrix[0],e):void DannError.error("None of the lengths of the matrix equal 1","Matrix.toArray")},Matrix.transpose=function(t){let e=new Matrix(t.cols,t.rows);for(let r=0;r<t.rows;r++)for(let i=0;i<t.cols;i++)e.matrix[i][r]=t.matrix[r][i];return e},Layer=function t(e,r,i,o,n,s){if(this.type=e,this.subtype=this.getSubtype(),"pool"!==this.subtype)"hidden"===this.type||"output"===this.type?(this.size=r,this.setFunc(i),this.layer=new Matrix(this.size,1)):"input"===this.type&&(this.size=r,this.layer=new Matrix(this.size,1));else if("pool"===this.subtype){if(this.stride=o,this.sampleSize=i,this.inputSize=r,void 0!==n&&void 0!==s)this.sizeX=n,this.sizeY=s;else if(this.sizeX=Math.sqrt(this.inputSize),this.sizeY=this.sizeX,this.sizeX!==Math.floor(this.sizeX))return console.error("Dann Error: the array can not be set in a square matrix"),void console.trace();this.size=t.getPoolOutputLength(i,o,this.sizeX,this.sizeY);let e=this.inputSize/this.sizeX,a=this.inputSize/this.sizeY;if(e!==Math.floor(e)&&a!==Math.floor(a))return console.error("Dann Error: the width & height value specified to arrange the inputted array as a matrix are not valid. (The array length must be divisible by the width & height values.)"),void console.trace();if(this.size!==Math.floor(this.size))return console.error("Dann Error: the Width must be divisible by the stride (jumps size). Width is the root of the array's length."),void console.trace();this.input=new Matrix(this.inputSize,1),this.layer=new Matrix(this.size,1),this.prefix=this.getPrefix(),this.poolfunc=poolfuncs[this.prefix],this.downsample=function(e,r,i){this.input=Matrix.fromArray(e);let o=t.selectPools(e,r,i,this.sizeX,this.sizeY),n=[];for(let t=0;t<o.length;t++)n[t]=this.poolfunc(o[t]);return this.layer=Matrix.fromArray(n),n}}else"string"==typeof this.type?(console.error("Dann Error: The Layer type '"+this.type+"' is not valid."),console.trace()):(console.error("Dann Error: You need to specify a valid type of Layer"),console.trace())},Layer.prototype.feed=function(t,e){if("pool"===this.subtype){let r=!1,i=!1,o=this.sampleSize,n=this.stride;if(void 0!==e&&(e.log&&(r=e.log),e.table&&(i=e.table)),t.length!==this.inputSize)return void DannError.error("Dann Error: The data you are trying to feed to this "+this.type+" layer is not the same length as the number of input this layer has.","Layer.prototype.feed");{let e=this.downsample(t,o,n);return r&&(i?console.table(e):console.log(e)),e}}DannError.error("This function can only be used by Layers with 'pool' subtype","Layer.prototype.feed")},Layer.getPoolOutputLength=function(t,e,r,i){return((r-t)/e+1)*((i-t)/e+1)},Layer.getSqIndex=function(t,e,r){return t*r+e},Layer.prototype.log=function(){console.log(this)},Layer.selectPools=function(t,e,r,i,o){t.length;if(i!==Math.floor(i))return;if(i/r!==Math.floor(i/r))return;let n=[];for(let s=0;s+e<=o;s+=r)for(let o=0;o+e<=i;o+=r){let r=[];for(let n=0;n<e;n++)for(let a=0;a<e;a++)r.push(t[Layer.getSqIndex(i,a+o,n+s)]);n.push(r)}return n},Layer.prototype.setFunc=function(t){let e=Layer.stringTofunc(t);void 0!==e?(this.actname=e.name,this.actname_d=e.name_d,this.actfunc=e.func,this.actfunc_d=e.func_d):DannError.error("Bad activation information","Layer.prototype.setFunc")},Layer.stringTofunc=function(t){let e,r,i=t,o=i+"_d";return e=activations[i],r=activations[o],void 0!==e?void 0!==r?{name:i,name_d:o,func:e,func_d:r}:void DannError.error("Dann Error: You need to create the derivative of your custom function. The activation function specified '"+t+"' does not have a derivative assigned. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc"):void DannError.error("Dann Error: the activation function '"+t+"' is not a valid activation function. The activation function was set to the default 'sigmoid'.","Layer.stringTofunc")},Layer.prototype.getPrefix=function(){let t=this.type,e=t.length;return t.slice(0,e-4)},Layer.prototype.getSubtype=function(){let t=this.type,e=t.length,r=t.slice(e-4,e);return"pool"===r?r:t},Dann=function(t=1,e=1){this.i=t,this.inputs=new Layer("input",t),this.o=e,this.outputs=new Layer("output",e,"sigmoid"),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.dropout=[],this.outs=[],this.loss=0,this.losses=[],this.lr=.001,this.arch=[t,e],this.epoch=0,this.recordLoss=!1,this.lossfunc=mse,this.lossfunc_s=this.lossfunc.name,this.percentile=.5},Dann.prototype.addDropout=function addDropout(rate){if(0===this.weights.length)return void DannError.error("You need to initialize weights before using this function, use Dann.prototype.makeWeights();","Dann.prototype.addDropout");let func=(t=>{let e=1-rate;return Math.floor(Math.random()+e)}).toString().replace(/rate/gm,rate),randomMap=eval(func),inactive=[];for(let t=0;t<this.Layers.length;t++){let e=new Array(this.Layers[t].size).fill(1).map(randomMap);inactive.push(e)}this.dropout=[];for(let t=0;t<this.weights.length;t++)this.dropout.push(new Matrix(this.weights[t].rows,this.weights[t].cols).initiate(1));for(let t=0;t<inactive.length;t++)if(0===t)for(let e=0;e<inactive[t].length;e++)0===inactive[t][e]&&this.dropout[t].fillCol(e,0);else if(t===inactive.length-1)for(let e=0;e<inactive[t].length;e++)0===inactive[t][e]&&this.dropout[t-1].fillRow(e,0);else for(let e=0;e<inactive[t].length;e++)0===inactive[t][e]&&(this.dropout[t-1].fillRow(e,0),this.dropout[t].fillCol(e,0))},Dann.prototype.addHiddenLayer=function(t,e){void 0!==e?void 0===activations[e]&&("string"==typeof e&&DannError.error("'"+e+"' is not a valid activation function, as a result, the activation function was set to 'sigmoid'.","Dann.prototype.addHiddenLayer"),e="sigmoid"):e="sigmoid",this.arch.splice(this.arch.length-1,0,t);let r=new Layer("hidden",t,e);this.Layers.splice(this.Layers.length-1,0,r)},Dann.prototype.backpropagate=function(t,e,r={}){let i=r.log||!1,o=r.mode||"cpu",n=r.saveLoss||!1,s=r.table||!1,a=r.dropout||void 0,l=new Matrix(0,0);if(e.length!==this.o)return void DannError.error("The target array length does not match the number of ouputs the dannjs model has.","Dann.prototype.backpropagate");if(l=Matrix.fromArray(e),"number"!=typeof this.lr)return void DannError.error("The learning rate specified (Dann.lr property) is not a number.","Dann.prototype.backpropagate");if(this.outs=this.feedForward(t,{log:!1,mode:o}),this.errors[this.errors.length-1]=Matrix.sub(l,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d),this.gradients[this.gradients.length-1].mult(this.errors[this.errors.length-1]),this.gradients[this.gradients.length-1].mult(this.lr),void 0!==a){if(a>=1)return void DannError.error("The probability value can not be bigger or equal to 1","Dann.prototype.backpropagate");if(a<=0)return void DannError.error("The probability value can not be smaller or equal to 0","Dann.prototype.backpropagate");this.addDropout(a)}for(let t=this.weights.length-1;t>0;t--){let e=Matrix.transpose(this.Layers[t].layer),r=Matrix.mult(this.gradients[t],e);void 0!==a&&(r=r.mult(this.dropout[t])),this.weights[t].add(r),this.biases[t].add(this.gradients[t]);let i=Matrix.transpose(this.weights[t]);this.errors[t-1]=Matrix.mult(i,this.errors[t]),this.gradients[t-1]=Matrix.map(this.Layers[t].layer,this.Layers[t].actfunc_d),this.gradients[t-1].mult(this.errors[t-1]),this.gradients[t-1].mult(this.lr)}let h=Matrix.transpose(this.Layers[0].layer),u=Matrix.mult(this.gradients[0],h);void 0!==a&&(u=u.mult(this.dropout[0])),this.weights[0].add(u),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,e,this.percentile),!0===n&&this.losses.push(this.loss),!0===i&&(console.log("Prediction: "),s?console.table(this.outs):console.log(this.outs),console.log("target: "),s?console.table(e):console.log(e),console.log("Loss: ",this.loss))},Dann.prototype.train=function(t,e,r){return this.backpropagate(t,e,r)},Dann.createFromJSON=function(t){const e=new Dann;return e.fromJSON(t),e},Dann.prototype.feedForward=function(t,e={}){let r=e.log||!1,i=e.table||!1,o=!1,n=pow(10,e.decimals)||1e3;if(void 0!==e.decimals&&(o=!0),t.length!==this.i){for(let t=0;t<this.o;t++)this.outs[t]=0;return DannError.error("The input array length does not match the number of inputs the dannjs model has.","Dann.prototype.feedForward"),this.outs}this.Layers[0].layer=Matrix.fromArray(t),0===this.weights.length&&(DannError.warn("The weights were not initiated. Please use the Dann.makeWeights(); function after the initialization of the layers.","Dann.prototype.feedForward"),this.makeWeights());for(let t=0;t<this.weights.length;t++){let e=this.Layers[t],r=this.Layers[t+1];r.layer=Matrix.mult(this.weights[t],e.layer),r.layer.add(this.biases[t]),r.layer.map(r.actfunc)}this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer);let s=this.outs;return!0===r&&(!0===o&&(s=s.map((t=>round(t*n)/n))),!0===i?(console.log("Prediction: "),console.table(s)):(console.log("Prediction: "),console.log(s))),s},Dann.prototype.feed=function(t,e){return this.feedForward(t,e)},Dann.prototype.fromJSON=function(t){this.i=t.arch[0],this.inputs=new Matrix(this.i,1),this.o=t.arch[t.arch.length-1],this.outputs=new Matrix(this.o,1);let e=JSON.parse(t.lstr);for(let t=0;t<e.length;t++){let r=JSON.parse(e[t]),i=new Layer(r.type,r.size,r.actname);this.Layers[t]=i}this.makeWeights();let r=JSON.parse(t.wstr);for(let t=0;t<r.length;t++)this.weights[t].set(JSON.parse(r[t]));let i=JSON.parse(t.bstr);for(let t=0;t<i.length;t++)this.biases[t].set(JSON.parse(i[t]));let o=JSON.parse(t.estr);for(let t=0;t<o.length;t++)this.errors[t].set(JSON.parse(o[t]));let n=JSON.parse(t.gstr);for(let t=0;t<n.length;t++)this.gradients[t].set(JSON.parse(n[t]));return this.lossfunc_s=t.lf,this.lossfunc=isBrowser?window[t.lf]:lossfuncs[t.lf],this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer),this.loss=t.loss,this.losses=[],this.lr=t.lrate,this.arch=t.arch,this.epoch=t.e,this.percentile=t.per,this},Dann.prototype.log=function(t={struct:!0,misc:!0}){let e=t.weights||!1,r=t.gradients||!1,i=t.errors||!1,o=t.biases||!1,n=t.struct||!1,s=t.misc||!1,a=t.layers||!1,l=t.table||!1,h=1e3;if(t.decimals>21?(DannError.error("Maximum number of decimals is 21.","Dann.prototype.log"),h=pow(10,21)):h=pow(10,t.decimals)||h,t.details){let l=t.details;r=l,e=l,i=l,o=l,n=l,s=l,a=l}if(0===this.weights.length&&this.makeWeights(),!0===n&&console.log("Dann Model:"),n){console.log("Layers:");for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t],r=e.type+" Layer: ",i="";0===t?(r="input Layer:   ",i="       "):t===e.length-1?(r="output Layer:  ",i="  ("+e.actname+")"):i="  ("+e.actname+")",console.log("\t"+r+e.size+i),a&&console.log(this.Layers[t])}}if(i){console.log("Errors:");for(let t=0;t<this.errors.length;t++){let e=Matrix.toArray(this.errors[t]),r=[];for(let t=0;t<e.length;t++)r[t]=round(e[t]*h)/h;console.log(r)}}if(r){console.log("Gradients:");for(let t=0;t<this.gradients.length;t++){let e=Matrix.toArray(this.gradients[t]),r=[];for(let t=0;t<e.length;t++)r[t]=round(e[t]*h)/h;console.log(r)}}if(e){console.log("Weights:");for(let e=0;e<this.weights.length;e++){this.weights[e].log({decimals:t.decimals,table:l})}}if(o){console.log("Biases:");for(let t=0;t<this.biases.length;t++){let e=Matrix.toArray(this.biases[t]),r=[];for(let t=0;t<e.length;t++)r[t]=round(e[t]*h)/h;console.log(r)}}s&&(console.log("Other Values: "),console.log("\tLearning rate: "+this.lr),console.log("\tLoss Function: "+this.lossfunc_s),console.log("\tCurrent Epoch: "+this.epoch),console.log("\tLatest Loss: "+this.loss)),console.log(" ")},Dann.prototype.makeWeights=function(t,e){let r=-1,i=1;void 0!==t&&void 0!==e&&(r=t,i=e);for(let t=0;t<this.Layers.length-1;t++){let e=this.Layers[t],o=this.Layers[t+1],n=new Matrix(o.layer.rows,e.layer.rows),s=new Matrix(o.layer.rows,1);n.randomize(r,i),s.randomize(1,-1),this.weights[t]=n,this.biases[t]=s,this.errors[t]=new Matrix(o.layer.rows,1),this.gradients[t]=new Matrix(o.layer.rows,1),void 0===o.actfunc&&o.setFunc("sigmoid")}for(let t=0;t<this.Layers.length;t++){let e=this.Layers[t];this.arch[t]=e.layer.rows}},Dann.prototype.mapWeights=function(t){if("function"==typeof t)for(let e=0;e<this.weights.length;e++)this.weights[e].map(t);else DannError.error("Argument must be a function","Dann.prototype.mapWeights")},Dann.prototype.mutateAdd=function(t){if("number"==typeof t)for(let e=0;e<this.weights.length;e++)this.weights[e].addPercent(t);else DannError.error("randomFactor argument must be a number.","Dann.prototype.mutateAdd")},Dann.prototype.mutateRandom=function(t,e){if("number"==typeof t){if(void 0!==e){if("number"!=typeof e)return void DannError.error("Probability argument must be a number.","Dann.prototype.mutateRandom")}else e=1;for(let r=0;r<this.weights.length;r++)this.weights[r].addRandom(t,e)}else DannError.error("Range argument must be a number.","Dann.prototype.mutateRandom")},Dann.prototype.outputActivation=function(t){if(void 0===activations[t]&&!isBrowser)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation"):void DannError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","Dann.prototype.outputActivation");this.Layers[this.Layers.length-1].setFunc(t)},Dann.prototype.setLossFunction=function(t,e=.5){this.percentile=e;let r=lossfuncs[t];if(void 0===r)return"string"==typeof t?void DannError.error("'"+t+"' is not a valid loss function, as a result, the model's loss function is set to 'mse' by default.","Dann.prototype.setLossFunction"):void DannError.error("Did not detect string value, as a result, the loss function is set to 'mse' by default.","Dann.prototype.setLossFunction");this.lossfunc_s=t,this.lossfunc=r},Dann.prototype.toFunction=function(t="myDannFunction"){let e="function "+t+"(input) {";e+="let w = [];";for(let t=0;t<this.weights.length;t++)e+="w["+t+"] = "+JSON.stringify(this.weights[t].matrix)+";";e+="let b = [];";for(let t=0;t<this.biases.length;t++)e+="b["+t+"] = "+JSON.stringify(this.biases[t].matrix)+";";e+="let c = "+JSON.stringify(this.arch)+";",e+="let a = [];";for(let t=1;t<this.Layers.length;t++){let r=this.Layers[t].actname;if(0!==t){let i=toEs6(activations[r]).toString().split("\n"),o="";for(let t=0;t<i.length;t++)o+=i[t];i=o.split("\t");let n="";for(let t=0;t<i.length;t++)n+=i[t];e+="a["+t+"] = "+n+";"}else e+="a["+t+"] = undefined;"}return e+="let l = [];",e+="l[0] = [];for (let i = 0; i < "+this.i+"; i++) {l[0][i] = [input[i]];};",e+="for (let i = 1; i < "+this.Layers.length+"; i++) {l[i] = [];for (let j = 0; j < c[i]; j++) {l[i][j] = [0];}};",e+="for (let m = 0; m < "+this.weights.length+"; m++) {for (let i = 0; i < w[m].length; i++) {for (let j = 0; j < l[m][0].length; j++) {let sum = 0;for (let k = 0; k < w[m][0].length; k++) {sum += w[m][i][k] * l[m][k][j];};l[m+1][i][j] = sum;}};for (let i = 0; i < l[m+1].length; i++) {for (let j = 0; j < l[m+1][0].length; j++) {l[m+1][i][j] = l[m+1][i][j] + b[m][i][j];}};for (let i = 0; i < l[m+1].length; i++) {for (let j = 0; j < l[m+1][0].length; j++) {l[m+1][i][j] = a[m+1](l[m+1][i][j]);}}};let o = [];for (let i = 0; i < "+this.o+"; i++) {o[i] = l["+(this.Layers.length-1)+"][i][0];};return o}",minify(e)},Dann.prototype.toJSON=function(){let t=[];for(let e=0;e<this.weights.length;e++)t[e]=JSON.stringify(this.weights[e].matrix);let e=JSON.stringify(t),r=[];for(let t=0;t<this.Layers.length;t++)r[t]=JSON.stringify(this.Layers[t]);let i=JSON.stringify(r),o=[];for(let t=0;t<this.biases.length;t++)o[t]=JSON.stringify(this.biases[t].matrix);let n=JSON.stringify(o),s=[];for(let t=0;t<this.errors.length;t++)s[t]=JSON.stringify(this.errors[t].matrix);let a=JSON.stringify(s),l=[];for(let t=0;t<this.gradients.length;t++)l[t]=JSON.stringify(this.gradients[t].matrix);return{wstr:e,lstr:i,bstr:n,estr:a,gstr:JSON.stringify(l),arch:this.arch,lrate:this.lr,lf:this.lossfunc_s,loss:this.loss,e:this.epoch,per:this.percentile}},isBrowser||(module.exports={dann:Dann,layer:Layer,matrix:Matrix,activations:activations,lossfuncs:lossfuncs,poolfuncs:poolfuncs,xor:XOR,makeXOR:makeXOR,makeBinary:makeBinary,add:Add});